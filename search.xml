<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F04%2F08%2Ffork%2F</url>
    <content type="text"><![CDATA[sads]]></content>
  </entry>
  <entry>
    <title><![CDATA[deterministic 和 determinat 有什么区别？]]></title>
    <url>%2F2017%2F05%2F08%2Fdeterminat-vs-deterministic%2F</url>
    <content type="text"><![CDATA[deterministic 和 determinat 翻译过来都是“确定性的”，但这并不代表它们可以互相混用，在并行计算的语境下，它们有着一些根本的差别。 从语源的角度来说，deterministic 的名词形式 determinism 指的是哲学中的决定论，决定论声称万物的发展皆是（由上帝 / 物理规律）事先决定好的，没有改变的余地。而 determinat 的名词形式 determinacy 指的是集合论中一个关注游戏必胜策略的子领域，或者直接指代“拥有必胜策略”这一属性。可以从语源看出，determinism 强调“没有什么可以改变”，而 determinacy 则更专注于“结果无法改变”（所谓必胜）这一点。 因此，当计算机科学引入这些术语时，自然借鉴了其原先的语义。比如，“确定性算法”这个术语的英文为“deterministic algorithm”，其解释如下： In computer science, a deterministic algorithm is an algorithm which, given a particular input, will always produce the same output, with the underlying machine always passing through the same sequence of states. Wikipediaen.wikipedia.org/wiki/Deterministic_algorithm 该释义强调了确定性算法在给定输入的情况下的两个必要属性： 永远产生相同的输出 永远产生相同的状态变化过程 可以看出，deterministic 的“确定性”既包含了结果的确定性，也包含了过程的确定性。 相比之下，determinat 则没有过程的确定性这一层含义。看看这段对 Id 语言（一门函数式并行编程语言）的描述： Programs in the functional subset of Id are guaranteed to be determinate, by which we mean that that it is impossible for the programmer to write a program that, despite different schedules on different runs, produces two different outcomes. Rishiyur S. Nikhil, 1991ID Language Reference Manual 这段描述特别强调了 determinate 是无关调度与运行过程的，只求结果的确定性。而正是对执行过程的限制与否，造成了 deterministic 和 determinat 的在并行计算语境下的根本差异。 一段程序（或者一个抽象的执行过程），如果使用 deterministic 进行描述，那么构成它的指令的执行顺序和执行结果都是确定的，这意味着这段程序是很难并行化的。要在保证指令的执行顺序的前提下并行运行多条指令在逻辑上就是不可能的（但在实现上是可能的，比如通过将一条指令进行拆分，从而能够并行运行多条指令的不同部分）。而 determinate 则不同，它只要求执行结果是确定的，这意味着程序内部可以通过并行运行多条互相无依赖的指令进行并行化。 举个简单的例子，计算 (1 + 2) * (3 + 4)，如果程序是 deterministic 的，那么计算会包含三步： 计算 1 + 2 计算 3 + 4 计算 3 * 7 而一个 determinate 的程序则能够通过并行化两步完成计算： 计算 1 + 2，同时计算 3 + 4 计算 3 * 7 容易推论，deterministic 的程序的运行时间取决于程序中的指令总数，而 determinate 的程序的运行时间取决于最长依赖路径的长度（假定资源无限）。这保证了 determinate 的程序能够充分利用系统的并行性进行加速。 总结来说，deterministic 和 determinate 都强调结果的确定性，但 deterministic 在此之上还要求执行过程的确定性。在表达“确定性”的场合，需要根据语义进行选择，而不是随意地混用它们[^1]。 [^1]: 最近有用 deterministic 替代 determinate 的趋势，在这种情况下，文献的作者通常对 deterministic 进行了分类或是对其使用语境进行了详细的描述]]></content>
      <categories>
        <category>撒旦</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[流计算核心概念解析之 window]]></title>
    <url>%2F2017%2F04%2F19%2Fintroduce-the-concept-of-windowing-in-streaming-processing%2F</url>
    <content type="text"><![CDATA[流计算是当前备受关注的一个大数据研究与应用领域，旨在实时或近实时地处理大量无界数据。区别于批处理，流处理中处理的数据集是无界的，所以聚集操作（如 reduce、sum、count 等）无法应用于整个数据集，否则聚集操作的结果可能永远都不会输出。我们需要将无界的数据集切分成一些有界的片段，将聚集操作应用于这些片段，从而能够在无界的数据集上得到持续的聚集操作输出结果，这一切分过程即被称为 window。流计算领域的许多概念、系统设计、实现细节都围绕着 window 展开，window 的支持程度也是我们对众多的流计算框架进行选型的重要依据。要理解 window，我们需要回答以下关键问题： 如何根据window进行数据划分？ 如何定义在window相关的操作中涉及的时间概念？ 如何输出基于window的操作的处理结果？ 下文将逐一回答这些关键问题，并在最后比较当前较热门的各流计算框架对 window 的支持程度。 如何根据 window 进行数据划分？由于流计算中的数据一般具有时间上的先后关系，window 切分一般基于数据的时间关系进行，常见的 window 划分策略包括（见图1[^image1-copyright]）： Tumbling window（也称为 fixed window）。Tumbling window 按固定的时间间隔对数据进行划分，将同一时间区间内的数据归为同一 window，每个数据只会属于一个 window； Sliding window。Sliding window 与 tumbling window 一样按固定时间间隔划分数据，每个时间区间被称为一个 window slide，而一个 window 区间可以包含多个 window slide，以固定的步长向后滑动，这意味着一个数据可以属于多个 window； Session window。Session window 使用数据间的时间间隔进行 window 切分，一旦前后两个数据间的时间间隔超过指定间隔，即将它们划入两个不同的 window，这种 window 划分策略适用于将数据划分为多个在时间上密切相关的 session。 图 1：window 策略 除了以基于时间进行划分外，基于数量进行划分的 window 划分策略也较常见。基于数量的划分策略主要包括 tumbling window 和 sliding window，只是将里面涉及的固定时间间隔替换为固定数量，这里不再赘述。 在支持 trigger 的系统（如 Google Cloud Dataflow 和 Flink）中，用户可以自定义 window 划分策略。例如，在 Google Cloud Dataflow（以下简称 Dataflow）中，用户可以根据时间、元素数目、数据内容（如是否包含换行符）等进行组合定义新的 trigger，从而根据具体业务场景灵活划分 window。 如何定义在window相关的操作中涉及的时间概念？当我们基于时间对数据进行划分时，我们是应该使用数据产生时的时间，还是数据进入系统时的时间，抑或是数据被某一操作处理时的时间？鉴于 window 操作涉及的时间概念如此复杂多样，流计算系统一般允许用户指定时间策略。常见的时间策略包含以下几种： Event time。Event time 指以数据自带的时间信息为作为时间基准，由于许多实时数据带有时间戳（如物联网设备的定时心跳数据），而围绕数据自带时间戳进行数据处理也是许多日志处理逻辑、周期统计逻辑的关键所在，event time 在流处理领域有着非常广泛的应用； Processing time。Processing time 指以数据实际被处理的时间作为时间基准，由于实现简单，几乎所有流计算系统都提供支持，但由于数据什么时候被处理依赖于具体的系统执行情况，processing time 基本只用于 event time 不可用的情况（如数据不带时间信息、系统不支持 event time 等）或与 event time 配合使用； Ingress time。Ingress time 指以数据进入流计算系统的时间作为时间基准，由于可以应用于无时间戳的数据、系统处理逻辑上类似于 event time 且能一定程度上避免 event time 数据乱序的问题，ingress time 在特定场景下可作为 event time 的合理替代方案。 由于 event time 能最精确地描述大量业务场景下的时间概念，支持 event time 能极大提升流计算系统的业务支持能力。但 event time 是流计算领域的“潘多拉魔盒”，包含许多复杂而微妙的问题。由于 event time 和数据处理时的时刻没有顺序对应关系，因此需要处理数据乱序问题。我们需要在下一个 window 的数据已经到达的情况下继续保持上一 window，以等待乱序数据的到达。由于数据集是无界的，而乱序数据什么时候到达并没有任何的保证，因此可能需要保持住所有的 window，这显然是不现实的。解决这一问题的常见方案是使用 watermark，即在数据源发送数据的过程中，在适当的位置插入 watermark 时间戳，表示在该 watermark 之后到达的数据中不包含早于时间戳所标记的时刻之前的数据，如此一来在接收到 watermark 时，早于 watermark 时间戳的 window 就能够被处理和清理。但在实际情况中，watermark 往往是不精确的，即在 watermark 到达后仍会有早于该时间戳的数据到达，造成 late data 问题。而 late data 的处理方式在不同系统中千差万别，存在着直接丢弃、更新之前 window 的状态、覆盖之前 window 的状态等多种处理方式，这里不再一一详述。 如何输出基于window的操作的处理结果？由于不同系统的 window 切分策略以及对 late data 的处理策略不同，同一 window 可能会出现一或多个输出结果的情况。在不支持 trigger 的系统中，如果直接丢弃 late data 或使用 late data 持续更新 window 输出结果，那么通常 window 处理结果是单输出的。一旦支持 trigger，则可能会出现在一个 window 中多次触发输出的情况，而使用 late data 覆盖或追加先前 window 结果的策略也会导致在 late data 出现时 window 多输出的情况。除了 Dataflow 和 Flink 外，现存的大部分系统是 window 单输出的。 各流计算框架对window支持程度对比下表总结了各热门的流计算框架对window支持程度的对比： Google Cloud Dataflow Apache Flink Apache Storm Spark Structured Streaming Spark Streaming Kafka Streams 版本 –[^dataflow-version] 1.1 1.0.0 Alpha 2.0.0 0.10.0 Tumbling window 支持 支持 支持 支持 支持 支持 Sliding window 支持 支持 支持 支持 支持 支持 Session window 支持 支持 不支持 不支持 不支持 不支持 Count-based window 支持 支持 支持 不支持 不支持 不支持 Trigger 支持 支持 不支持 不支持 不支持 不支持 Event time 支持 支持 支持 支持 不支持 支持 Processing time 支持 支持 支持 不支持 支持 支持 Ingress time 不支持 不支持 不支持 不支持 不支持 支持 Window输出 多输出 多输出 单输出 单输出 单输出 单输出 可以看到，目前对 window 支持最完善的流计算框架是 Dataflow 和 Flink；Storm 在最新的 1.0.0 中加入内置的 window 支持，而 Kafka Streams 则是随 Kafka 0.10.0 版本一同释出的新流计算框架，两者对 window 的支持都较为完善，但是否稳定可靠则需要时间的验证；而 Spark 原有的流计算框架 Spark Streaming 由于只支持基于 mini-batch 的 processing-time window，对 window 的支持一直很薄弱，随 Spark 2.0.0 释出的 Structured Streaming 旨在支持 event-time window，补足 Spark 在流处理上的能力，但仍然处于相当早期的阶段，各种 window 特性的支持都有所缺失。鉴于流处理领域对于优秀流处理框架的旺盛需求，未来一定会有更多对 window 支持更完善的流处理框架涌现出来，让我们拭目以待。 参考链接 The world beyond batch: Streaming 102 Apache Flink 1.1 Documentation: Windows Concepts — Confluent Platform 3.0.0 documentation Developer Guide — Confluent Platform 3.0.0 documentation Windowing Support in Core Storm Spark Streaming - Spark 2.0.0 Documentation Structured Streaming Programming Guide - Spark 2.0.0 Documentation [^image1-copyright]: 本图摘自 https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-102，版权归原作者所有[^dataflow-version]: Dataflow 为 Google 提供的云服务，由于没有开源，并不清楚其内部版本号]]></content>
      <categories>
        <category>流计算</category>
      </categories>
      <tags>
        <tag>window</tag>
        <tag>streaming</tag>
        <tag>bigdata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Cheat Sheet]]></title>
    <url>%2F2017%2F04%2F18%2Fgit-cheat-sheet%2F</url>
    <content type="text"><![CDATA[Git 本地更改操作初始化 初始化一个 Git 仓库：git init 提交修改 添加文件到暂存区：git add &lt;file&gt; 添加所有修改到暂存区：git add . 将暂存区的修改提交到版本库：git commit -&gt; 编辑 commit message -&gt; 保存 commit message 较简单时，可以：git commit -m &quot;&lt;message&gt;&quot; 为文件添加执行权限，并将修改添加到暂存区：git update-index --chmod=+x &lt;file&gt; 回退修改 回退工作区的修改：git checkout -- &lt;file&gt; 回退工作区的修改，但保存现场：git stash 恢复现场：git stash pop 查看保存的现场：git stash list 回退暂存区的修改到工作区：git reset HEAD &lt;file&gt; 回退版本库的修改到工作区：git reset &lt;commit&gt; 或 git reset –-mixed &lt;commit&gt; 回退版本库的修改到暂存区：git reset –-soft &lt;commit&gt; 回退版本库的修改（不保留）：git reset --hard &lt;commit&gt; 如果错误执行了该回退操作，可以通过 git reflog 查看命令历史，命令历史中记载了回退前的 commit id，可以执行 git reset --hard &lt;commit&gt; 回退该回退操作 回退所有未被跟踪的文件：git clean -df 删除文件 从暂存区 + 工作区中删除：git rm &lt;file&gt; 从暂存区中删除：git rm --cached &lt;file&gt; 跟踪文件 强制跟踪指定文件：git update-index --no-assume-unchanged &lt;file&gt; 强制不跟踪指定文件：git update-index --assume-unchanged &lt;file&gt; Git 比较操作 比较工作区和暂存区的指定文件：git diff &lt;path&gt; 比较所有文件：git diff 比较工作区和指定 commit 的指定文件：git diff &lt;commit&gt; &lt;path&gt; 比较所有文件：git diff &lt;commit&gt; 比较暂存区和指定 commit 的指定文件：git diff --cached &lt;commit&gt; &lt;path&gt; 比较暂存区和 HEAD 的指定文件：git diff --cached &lt;path&gt; 比较所有文件：git diff --cached &lt;commit&gt; 比较 commit A 和 commit B 的指定文件：git diff &lt;A&gt; &lt;B&gt; &lt;path&gt; 比较 HEAD 和 commit B 的指定文件：git diff ..&lt;B&gt; &lt;path&gt; 比较 commit A 和 HEAD 的指定文件：git diff &lt;A&gt;.. &lt;path&gt; 比较 commit A 与 commit B 的 merge base 和 commit B 的指定文件：git diff &lt;A&gt;...&lt;B&gt; &lt;path&gt; 比较 HEAD 与 commit B 的 merge base 和 commit B 的指定文件：git diff ...&lt;B&gt; &lt;path&gt; 比较 commit A 与 HEAD 的 merge base 和 HEAD 的指定文件：git diff &lt;A&gt;... &lt;path&gt; 使用 difftool 比较文件，命令参数与 git diff 一致，但使用 git difftool 子命令 配置 difftool： 编辑 ~/.gitconfig： 1234[diff] tool = meld[difftool &quot;meld&quot;] path = C:\\path\\to\\meld\\Meld.exe Git 历史操作 查看分支合并图：git log --graph 配置 git lg 作为查看格式良好的历史记录的命令： 12[alias] lg = log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit Git 分支操作 查看当前分支：git branch 基于当前分支创建新分支：git branch &lt;name&gt; 基于当前分支创建并切换到新分支：git checkout -b &lt;name&gt; 基于指定分支创建并切换到新分支：git checkout -b &lt;name&gt; &lt;origin-branch&gt; 切换到指定分支：git checkout &lt;name&gt; 合并指定分支到当前分支：git merge &lt;name&gt; 合并时在指定分支基础上重新提交当前分支从 merge base 开始的 commit：git rebase -i &lt;name&gt; rebase 时历史会从旧到新显示，编辑历史时有如下 command 可用： pick：直接入库 edit：在入库前允许重新编辑 commit reword：在入库前允许重新编辑 commit message squash：与前次提交进行 commit 合并 fixup：同 squash，但丢弃 commit message 示例 原始 log 如下： 1234debug: commit1debug: commit2debug: commit3fix: commit4 使用以下 command： 1234pick debug: commit1fixup debug: commit2fixup debug: commit3squash fix: commit4 结果： 1fix: commit4 继续检查下个 commit：git rebase --continue 取消本次 rebase：git rebase --abort 使用指定工具进行 merge 操作：git mergetool 配置 merge 工具： 1234[merge] tool = meld[mergetool &quot;meld&quot;] path = C:\\path\\to\\meld\\Meld.exe 删除指定分支：git branch -d &lt;name&gt; 删除未合并分支：git branch -D &lt;name&gt; Git 远程仓库操作 克隆远程仓库到当前目录：git clone &lt;repo-url&gt; 克隆远程仓库到指定目录：git clone &lt;repo-url&gt; &lt;dir&gt; &lt;dir&gt; 目录下会出现 .git 目录 关联远程仓库：git remote add &lt;repo-name&gt; &lt;repo-url&gt; &lt;repo-name&gt; 惯例命名为 origin &lt;repo-url&gt; 一般格式为 git@server-name:path/repo-name.git 查看远程仓库信息：git remote -v 拖取指定远程仓库：git fetch &lt;repo-name&gt; 拖取指定远程仓库的指定分支然后合并到当前分支：git pull &lt;repo-name&gt; &lt;branch-name&gt; 推送指定分支到指定远程仓库：git push &lt;repo-name&gt; &lt;branch-name&gt; 推送当前分支到指定远程仓库：git push &lt;repo-name&gt; 推送当前分支到上游仓库：git push 要配置指定远程仓库为上游仓库，可以： 在第一次推送时使用 -u 指定：git push -u &lt;repo-name&gt; &lt;branch-name&gt; 直接配置：git branch --set-upstream &lt;branch-name&gt; &lt;repo-name&gt;/&lt;branch-name&gt; 删除指定远程仓库的指定分支：git push &lt;repo-name&gt; :&lt;branch-name&gt; 如果由于远程仓库的 HEAD 指向待删除的分支而无法进行删除操作，可以先把 HEAD 指向其他分支，在远程仓库上进行以下操作：git symbolic-ref HEAD refs/heads/&lt;other-branch-name&gt;，在删除分支后再切换回来 Git 标签操作 基于 HEAD 新建标签：git tag &lt;name&gt; 基于指定 commit 新建标签：git tag &lt;name&gt; &lt;commit&gt; 指定标签信息：git tag -m &lt;message&gt; &lt;name&gt; 使用PGP签名标签：git tag -s &lt;name&gt; 查看标签：git tag 推送指定标签到指定远程仓库：git push &lt;repo-name&gt; &lt;tag-name&gt; 推送全部标签到指定远程仓库：git push &lt;repo-name&gt; --tags 在指定远程仓库删除指定标签：git push &lt;repo-name&gt; :refs/tags/&lt;tag-name&gt; Git 子模块操作 添加 submodule：git submodule add -b &lt;branch&gt; --name &lt;name&gt; &lt;repo&gt; &lt;path&gt; 查看 submodule 状态：git submodule status clone 含 submodule 的项目 方法一：git clone &lt;repo&gt; --recursive 方法二： 12git clone &lt;repo&gt;git submodule update --init --recursive 删除 submodule： 1234git deinit &lt;path&gt;git rm --cached &lt;path&gt;rm -rf &lt;path&gt;[edit .gitmodules to remove submodule item] 在 submodule 中执行命令：git submodule foreach &lt;command&gt; 更新 submodule：git submodule update --recursive --remote Git 配置 配置 committer： 12git config --global user.name &lt;user-name&gt;git config --global user.email &lt;user-email&gt; 让命令行输出显示颜色：git config --global color.ui true 让 non-bare repo 能被 push：git config receive.denyCurrentBranch updateInstead 让 Git 不要自动转换 CRLF：git config --global core.autocrlf false 让 Git 忽视文件的 mode 变化：git config --global core.fileMode false 为复杂操作配置别名： 示例： 12[alias] sy = &quot;!f() &#123; git status; git add .; git commit; git push origin-test $&#123;1&#125;; &#125;; f&quot; 配置 Git 的自动补全和命令行 prompt： 在 ~/.bashrc 中加入如下配置： 12345678910111213source $&#123;GIT_SOURCE_DIR&#125;/contrib/completion/git-completion.bashsource $&#123;GIT_SOURCE_DIR&#125;/contrib/completion/git-prompt.shfunction color_my_prompt &#123; local __user_and_host="\[\033[01;32m\]\u@\h" local __cur_location="\[\033[01;34m\]\w" local __git_branch_color="\[\033[31m\]" local __git_branch='`git branch 2&gt; /dev/null | grep -e ^* | sed -E s/^\\\\\*\ \(.+\)$/\(\\\\\1\)\ /`' local __prompt_tail="\[\033[35m\]$" local __last_color="\[\033[00m\]" export PS1="$__user_and_host $__cur_location $__git_branch_color$__git_branch$__prompt_tail$__last_color "&#125;color_my_prompt 豆知识commit 别名在 Git 中，HEAD 表示当前版本，也就是最新的提交，上一个版本就是 HEAD^，上上一个版本就是 HEAD^^，上100个版本写成 HEAD~100。 dry run很多命令都有 -n 或 --dry-run 选项，使用了该选项后，命令不会直接运行，而是输出它将执行的内容，供用户判断执行的内容是否和预期一致，从而决定是否实际执行该命令。这避免了一些手误的情况，在某些重要的操作上很有用。 --Git 的命令中常含有 --，它用来分割 Git 命令的选项和文件/文件列表，以防某些文件名被误认为是选项。 在 Windows 下启动 Git server将指定目录下所有的仓库都通过 Git server 暴露给其他人： 1git daemon --base-path=/path/to/workplace --export-all]]></content>
      <categories>
        <category>Cheat Sheet</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>cheat-sheet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Travis 自动部署博客到 Github Pages]]></title>
    <url>%2F2017%2F04%2F15%2Fcontinuous-deployment-blog-to-github-pages-with-travis%2F</url>
    <content type="text"><![CDATA[由于博客的源码和生成站点位于不同的代码仓库中（源码位于 uchuhimo/uchuhimo.me，生成的静态站点位于 uchuhimo/uchuhimo.github.io，即个人 GitHub Pages 的仓库），文章的发布过程需要提交两次。作为拥有懒惰这种美德的程序员，自然会开始折腾只需要提交一次、博客就自动部署到 GitHub Pages 上的方法——这里就轮到 Travis 登场了。 接下来，我会先介绍自动部署的原理，再讲解搭建的过程。 原理Travis 为 GitHub 上的开源项目提供免费的持续集成（CI）服务，只要你向指定仓库提交了代码，Travis 就会根据配置自动运行 CI 任务。利用这个特性，我们可以做到在一次提交过程中触发如下流程： 内容编辑完成，向博客的源码仓库 push 代码 GitHub 通过 hook 告诉 Travis 有新的提交，Travis 启动新的 CI 任务 在 CI 任务中，代码被 clone 到 Travis 的构建服务器上 构建服务器准备好 Node.js 的运行环境，运行 Hexo 的生成命令，并将生成的静态站点 push 到 GitHub Pages 的仓库中，博客部署完成 这个过程中的难点在于如何给予 Travis push 你的 GitHub Pages 仓库的权限。有两种方法可以获得 push 权限： SSH 私钥：只要在 GitHub 上配了相应公钥，就可以通过 SSH 进行 push Personal access token：只要在 GitHub 上生成了 personal access token，就可以通过 HTTPS 进行 push 但是，无论是使用上述的哪种方法，SSH 私钥 / personal access token 都不能出现在 Travis 的配置文件里，因为 Travis 的配置文件（即 .travis.yml）会出现在博客的源码仓库里，这意味着任何能访问你提交历史的路人（对于 GitHub 的公开项目来说，意味着任何人）都能获取到它们并用来向你的仓库进行任意提交——这是灾难性的（顺带一提，GitHub 如果发现你的代码仓库中含有 personal access token，会自动删除相应token，因此向仓库提交 personal access token 的行为并不会带来风险，只是没有意义而已，因为 token 会直接失效）。因此，我们需要使用 Travis 客户端对 SSH 私钥 / personal access token 进行加密，然后在 CI 任务中解密并使用它们。 原理解释先到这里，下面我们直接动手做吧~ 准备工作 注册 Travis 并将 Github Pages 的源码项目加入 Travis 准备一个 Github 的 personal access token 安装 Travis 客户端（加入了惯例的“换国内源”环节，不用谢我^_^）： 123456789101112131415# install rvmgpg --keyserver hkp://keys.gnupg.net:80 --recv-keys D39DC0E3\curl -sSL https://get.rvm.io | bash -s stablesource /home/uchuhimo/.rvm/scripts/rvmecho "ruby_url=https://cache.ruby-china.org/pub/ruby" &gt; ~/.rvm/user/db# install rubyrvm install 2.4.0rvm use 2.4.0 --default# configure gemgem sources --add https://gems.ruby-china.org/ --remove http://rubygems.org/# install travisgem install travis 配置 Travis 在博客的源码项目下新建 .travis.yml：touch .travis.yml 加密上文生成的 personal access token：travis encrypt GITHUB_TOKEN=&quot;&lt;personal-access-token&gt;&quot; --add 在 .travis.yml 中添加如下内容（记得替换变量）： 12345678910111213141516171819language: node_jsnode_js: - "7"before_deploy: - hexo generate # generate static sitedeploy: provider: pages # deploy to GitHub Pages skip_cleanup: true # don't clean generated site github_token: $GITHUB_TOKEN # provide the encrypted token on: branch: master repo: &lt;username&gt;/&lt;github-pages-repo-name&gt; # optional, defaults to current repo local_dir: public # optional, defaults to the current directory target_branch: master # optional, defaults to "gh-pages" fqdn: &lt;custom-domain-url&gt; # optional project_name: &lt;project-name&gt; # optional, defaults to value of fqdn or repo email: &lt;committer-email&gt; # optional, defaults to "deploy@travis-ci.org" name: &lt;committer-name&gt; # optional, defaults to "Deployment Bot" 提交更改即可触发 Travis 自动更新 Github Pages 到 https://travis-ci.org/&lt;username&gt;/&lt;blog-source-repo-name&gt; 页面查看构建是否成功 后记在最终采用上述方案之前，我也看了网上现有的方案，感觉都多多少少有些繁琐，因此在自己折腾出来后才决定分享出来，供大家参考。 下面是我看到的几个比较靠谱的方案，以供对比： 基于 SSH 的方案：用 Travis CI 自動部署網站到 GitHub 这是 Hexo 作者 tommy351 自己部署 Hexo 的官方网站用的方案，感觉看完都有点不想折腾了，真的很繁琐。 基于 personal access token 的方案：使用 Travis CI 自动更新 GitHub Pages 这是 NexT 作者 iissnan 部署 NexT 文档的方案，使用的和我一样是 personal access token，iissnan 自己撸了提交到 GitHub Pages 的命令，而我直接使用了 Travis 提供的部署插件，会更简单和易维护一些（其实真正的原因是我懒）。另一点不同是 iissnan 使用了 gulp 管理构建过程，而我直接使用 Hexo 的命令进行构建，因此构建的命令会有所不同。 参考链接 GitHub Pages Deployment - Travis CI]]></content>
      <categories>
        <category>创世记</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>Hexo</tag>
        <tag>Travis</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 Hexo 和 GitHub Pages 搭建这个博客]]></title>
    <url>%2F2017%2F04%2F11%2Fgenesis%2F</url>
    <content type="text"><![CDATA[一个博客的搭建过程分为三步： 编写：包含内容的书写与格式的配置 构建：从编写的原始内容生成可发布的最终内容 发布：让待发布的内容对读者可见 依托于博客平台（如博客园、新浪博客等）发布内容的用户只需要关注编写部分，但要搭建一个独立的个人博客则以上三方面都需要关心。幸运的是，现在有大量的工具帮助我们简化这个过程：丰富的 Markup 语言简化了编写；强大的静态站点生成器简化了构建；友好的托管平台简化了发布。 这个博客的诞生也得益于这些工具： 编写：使用 Markdown，内置大量层级、列表、超链接、代码等的简便语法支持 构建：使用 Hexo，几条命令完成生成、预览、发布步骤 发布：使用 GitHub Pages 进行托管，方便又免费 接下来我会按以下顺序介绍如何基于这些工具完成整个博客的搭建过程： 环境准备 Hexo 和 NexT 主题的使用 GitHub Pages 的配置与部署 绑定自定义域名（可选） Hexo 的详细配置过程 环境准备 安装 Node.js 官网下载：https://nodejs.org/en/download/ 更换成国内镜像源： 123[edit ~/.npmrc]registry=https://registry.npm.taobao.org[end] 安装 Hexo 1npm install -g hexo-cli 常用 Hexo 命令 初始化目录：hexo init [folder] 新建文章：hexo new [layout] &lt;title&gt; 或 hexo n [layout] &lt;title&gt; 新建草稿：hexo new draft &lt;title&gt; 将草稿发布为正式文章：hexo publish &lt;title&gt; 生成静态文件：hexo generate 或 hexo g 监听文件变化：hexo g --watch 或 hexo g -w 部署：hexo deploy 或 hexo d 先生成后部署：hexo d -g 启动本地服务器（服务器会监听文件变化并自动更新）：hexo server 或 hexo s 启动调试：hexo s --debug 预览草稿：hexo s --draft 清除缓存：hexo clean 使用 NexT 主题下载主题12cd &lt;your-hexo-site&gt;git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题编辑 _config.yml： 1theme: next 设置语言编辑 _config.yml： 1language: zh-Hans 查看是否生效123hexo cleanhexo generatehexo server 创建 GitHub Pages在自己的 GitHub 账号下创建名为 &lt;username&gt;.github.io 的项目即可。 部署博客到 GitHub Pages设置 ssh 访问 GitHub 仓库 生成 ssh key ：ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 在 GitHub -&gt; Settings -&gt; SSH and GPG keys -&gt; New SSH key 添加 ~/.ssh/id_rsa.pub 中的内容 安装 git-deploy 插件1npm install hexo-deployer-git --save 配置 git-deploy 插件编辑 _config.yml： 1234deploy: type: git repo: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 部署1hexo d -g 绑定自定义域名 在万网申请域名：https://wanwang.aliyun.com/ 其他可供选择的域名服务商： GoDaddy：世界上最大的域名注册商，但续费比较贵 freenom：可以找到免费的域名，但都是很奇怪的后缀，比如.ml（感觉做机器学习的初创公司可以弄来玩玩，反正不要钱wwww） 不同域名服务商的详细对比（主要是价格）：Domain Name Price and Availability 注册 DNSPOD：https://www.dnspod.cn 在 DNSPOD 的控制台选择：域名解析 -&gt; 全部域名 -&gt; 添加域名，将在万网申请到的域名填入 在万网的域名控制台的相应域名依次选择：管理 -&gt; 基本信息 -&gt; 修改 DNS，将 DNS 修改为 DNSPOD 的 DNS：f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net 在 DNSPOD 的控制台选择相应域名并添加记录，主机记录使用 “@”，记录类型选择 “CNAME”，记录值使用 “&lt;username&gt;.github.io“，保存 在 Hexo 中绑定域名： 123[create/edit source/CNAME]&lt;your-domain-name&gt;[end] 重新部署，并等待 DNS 生效 如果需要绑定多个域名，可以将 GitHub Pages 绑定到其中一个域名，并把其他域名重定向到该域名。在 DNSPOD 中，这可以通过在需要重定向的域名中添加类型为”显性URL”的记录实现。具体请参考”隐/显性转发“和”DNSPod 支持域名301重定向吗？“。 配置 Hexo设置头像编辑 _config.yml： 1avatar: &lt;avatar-url&gt; 添加标签页面 新建页面： 1hexo new page tags 设置页面（编辑 source/tags/index.md）： 1234---type: "tags"comments: false--- 修改菜单（编辑 themes/next/_config.yml）： 12menu: tags: /tags 添加分类页面 新建页面： 1hexo new page categories 设置页面（编辑 source/categories/index.md）： 1234---type: "categories"comments: false--- 修改菜单（编辑 themes/next/_config.yml）： 12menu: tags: /categories 添加 about 页面 新建页面： 1hexo new page about 设置页面（编辑 source/about/index.md） 修改菜单（编辑 themes/next/_config.yml）： 12menu: about: /about 首页文章显示摘要在文章中适当位置插入 &lt;!--more--&gt;，该位置之前的部分即为摘要，会显示在首页中。 显示文章更新时间编辑 themes/next/_config.yml： 123# Post meta display settingspost_meta: updated_at: true 文章更新时间默认使用文件的修改时间，如果想自己指定，可以在文章的 Front-matter （即文件最上方以 --- 分隔的区域）中加入： 1updated: &lt;update-time&gt; 其中，&lt;update-time&gt; 的格式示例为 2017-04-11 16:29:50。 设置代码高亮编辑 themes/next/_config.yml： 1234# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal 添加 Creative Commons 署名协议编辑 themes/next/_config.yml： 12345678910# Declare license on posts# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: bypost_copyright: enable: true license: CC BY 4.0 license_url: http://creativecommons.org/licenses/by/4.0/ 添加评论系统使用 Disqus 作为评论系统。需要注意的是，Disqus 已经被墙，所以不翻墙是看不到的，只能相信大家都是带着梯子来的了。。。 编辑 themes/next/_config.yml： 12345# Disqusdisqus: enable: true shortname: &lt;your-shortname&gt; count: true 也可以使用来必力代替 Disqus，编辑 themes/next/_config.yml： 1livere_uid: &lt;your-uid&gt; 侧边栏社交链接编辑 themes/next/_config.yml： 123456789101112131415# Social linkssocial: GitHub: https://github.com/your-user-name Twitter: https://twitter.com/your-user-name 微博: http://weibo.com/your-user-name 豆瓣: http://douban.com/people/your-user-name 知乎: http://www.zhihu.com/people/your-user-name# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 开启打赏功能编辑 themes/next/_config.yml： 123reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /path/to/wechat-reward-imagealipay: /path/to/alipay-reward-image 腾讯公益404页面编辑 source/404.html： 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 站点建立时间编辑 themes/next/_config.yml： 1since: 2017 阅读次数统计使用不蒜子统计，编辑 themes/next/_config.yml： 1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; page_pv_footer: 集成搜索服务使用本地搜索，按以下步骤配置： 安装 hexo-generator-searchdb 插件： 1npm install hexo-generator-searchdb --save 编辑 _config.yml： 12345search: path: search.xml field: post format: html limit: 10000 编辑 themes/next/_config.yml： 123# Local searchlocal_search: enable: true 本地搜索的一个替代方案是 Algolia，按以下步骤配置： 前往 Algolia 注册页面注册一个新账户。注册后的 14 天内拥有所有功能（包括收费类别的），之后若未续费会自动降级为免费账户，免费账户总共有 10,000 条记录，每月有 100,000 的可操作数。注册完成后，创建一个新的 Index。 安装 hexo-algolia 插件（默认使用的 0.1.1 版本会出现问题，必须指定 0.2.0 版本）： 1npm install --save hexo-algolia@0.2.0 在 Algolia 网站上找到需要使用的配置值，包括 ApplicationID、Search API Key、Admin API Key。 编辑 _config.yml： 12345algolia: applicationID: &lt;application-id&gt; apiKey: &lt;search-api-key&gt; indexName: &lt;index-name&gt; chunkSize: 5000 由于 Admin API Key 需要保密保存，我们在一个单独的文件 _config.private.yml 中配置它： 12algolia: adminApiKey: &lt;admin-api-key&gt; 如果使用了 Git 进行源码管理的话，在 .gitignore 中忽略 _config.private.yml 和 _multiconfig.yml （这是在更新 Index 过程中合并 _config.yml 和 _config.private.yml 的内容生成的文件，里面也包含 Admin API Key），防止 Admin API Key 被公开到 GitHub 等托管网站上。 执行以下命令更新 Index： 1hexo algolia --config _config.yml,_config.private.yml 需要注意的是，在 3.3.1 版本的 Hexo 中，该命令会出现下列报错信息： 1221:15:11.652 ERROR Local hexo not found in C:\projects\archive\xxx11:15:11.654 ERROR Try running: &apos;npm install hexo --save&apos; 这是 Hexo 的 bug，具体请参考： ERROR when trying to use two alternative configs · Issue #2518 · hexojs/hexo Fix multiple config issue #2518 by NoahDragon · Pull Request #2520 · hexojs/hexo 该 bug 已在该 commit 中修复：Fix multiple config issue #2518 (#2520) · hexojs/hexo@fbdee90，并在 3.3.5 版本中 release。 编辑 themes/next/_config.yml： 123456789# Algolia Searchalgolia_search: enable: true hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms" 添加 sitemap 插件安装 hexo-generator-sitemap 插件： 1npm install hexo-generator-sitemap --save 配置（编辑 _config.yml）： 12sitemap: path: sitemap.xml 添加蜘蛛协议 robots.txt新建 source/robots.txt： 12345678910111213141516User-agent: *Disallow: /CNAMEDisallow: /READMEAllow: /Allow: /about/Allow: /archives/Allow: /categories/Allow: /tags/Allow: /css/Allow: /images/Allow: /js/Allow: /lib/Sitemap: &lt;your-domain-name&gt;/sitemap.xml 设置 RSS安装 hexo-generator-feed 插件： 1npm install hexo-generator-feed --save 配置（编辑 _config.yml）： 123456feed: type: atom path: atom.xml limit: 20 # Maximum number of posts in the feed (Use 0 or false to show all posts) hub: content: 添加脚注/上标/下标/缩写支持由于 Hexo 默认使用的 Markdown renderer 是 marked，它不支持脚注/上标/下标/缩写，我们可以使用 Markdown-it 替代 marked： 12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save 配置（编辑 _config.yml）： 12345678910111213141516171819202122# Markdown-it config## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wikimarkdown: render: html: true xhtmlOut: false breaks: false linkify: true typographer: false quotes: '“”‘’' plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup anchors: level: 2 collisionSuffix: 'v' permalink: false permalinkClass: header-anchor permalinkSymbol: ¶ 参考链接 hexo你的博客 | 不如 手把手教你使用Hexo + Github Pages搭建个人独立博客 | 令狐葱@前端笔记 Documentation | Hexo NexT 使用文档 如何使用Hexo寫草稿? | 點燈坊]]></content>
      <categories>
        <category>创世记</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
